---
title: "Meu arquivo RMarkdown"
author: "Meu nome"
date: "3 de março de 2023"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
library(ggplot2)
library(rmarkdown)
library(htmlwidgets)
library(data.table)
library(arules)
library(arulesViz)
library(tidyr)
library(dplyr)
library(reshape2)
```


Vamos trabalhar com um dataset de vendas on-line de alguns países da Europa. Ao final, teremos conhecimento das assossiações existentes entre os itens mais vendidos, o que poderá nos levar à um modelo de recomendação de compra.

## Sobre o conjunto de dados

Fonte: [UCI Machine Learning Repository](http://archive.ics.uci.edu/ml/machine-learning-databases/00352/Online%20Retail.xlsx)

Este dataset contém dados de varejo, e fornece dados de transações de um site com base no Reuni Unido.

## Motivação

Com base nas transações já registradas, queremos recomendar ao cliente compras que são bastante prováveis. Desta forma, estaremos aumentando o ticke-médio/cliente.

## Iniciando análise:

Carregando pacotes (OBS: lembre-se de instalar os pacotes antes do carregamento, com install.packages())
```{r}
library(htmlwidgets)
library(data.table)
library(arules)
library(arulesViz)
library(tidyr)
library(dplyr)
library(reshape2)

```

Suprimindo warnings
```{r}
options(warn = -1)

```

Extraindo dados
```{r}
download.file('https://raw.githubusercontent.com/Fagner608/MBA_apriori_with_R/main/retail.csv', 'dados.csv')

```
Lendo dados

```{r}
dados = read.csv('dados.csv')

head(dados)
```

Eliminando colunas que não serão usadas

```{r}
dados = dados[, -c(1,3,5:9)]
```

Visualizando
```{r}
head(dados)
```

Vamos criar algumas funções, que receberão os atributos, e investigarão eventual padrão de dado que não paraça normal.
```{r}
# Função para apontar na's e valores únicos por colunas
info_cols = function(data.frame){

  na_s = colSums(is.na(data.frame))
  unique_v = apply(data.frame, 2, n_distinct)
  tipo_dados = apply(data.frame, 2, typeof)
  

  return(data.frame(na = na_s, valores_unicos = unique_v, tipo_dado = tipo_dados))
}

info_cols(dados)

```

Vamos verificar se existem caracteres alfabéticos no atributo invoiceNO
```{r}

indices = grep("[A-Za-z]", dados$InvoiceNo)

length(indices)
```

Visualizando
```{r}
head(dados[indices, ])
```

São dados de compras canceladas. Vamos eliminar esses dados da análise
```{r}
dados_clean = dados[-indices, ]
```

Vamos atribuir o tipo correto aos dados
```{r}
dados_clean$InvoiceNo = as.integer(dados_clean$InvoiceNo)
```

Visualizando
```{r}
info_cols(dados_clean)
```

Aplicando a função dcast() do pacote reshape2, vamos transformar os dados em uma matriz de presente, fazendo com que cada linha represente uma compra, e cada coluna represente um poduto, registando sua compra ou não.
```{r}
dados_transacoes = dcast(dados_clean, InvoiceNo ~ Description, fun.aggregate = length)
```

Visualizando
```{r}
head(dados_transacoes)
```

Dimensões
```{r}
dim(dados_transacoes)
```
Elegendo os top-50 produtos vendidos

```{r}

top_50 = head(sort(colSums(dados_transacoes[, -1] == 0), decreasing = F), 50)

dados_transacoes = dados_transacoes[, c('InvoiceNo', names(top_50))]

dados_transacoes = dados_transacoes[, -2]

head(dados_transacoes)

```

Trasnformando os dados em uma matriz
```{r}
dados_matrix = as.matrix(dados_transacoes[ , -1])
```

Casting para o tipo 'transaction'
```{r}
transacoes = as(dados_matrix, 'transactions')
```

Aplicando apriori
```{r}
regras = apriori(transacoes,
                parameter = list(conf = 0.5, supp = 0.01, minlen = 3))
```

Filtrando regras redundantes
```{r}
regras_clean = regras[!is.redundant(regras)]

length(regras_clean)
```

Inspecionando as top_50 regras
```{r}
inspect(head(sort(regras_clean, by = 'support', decreasing = T),20))
```

É possível observar que a descrição dos produtos não traz apenas a sua definição (seu substantivo); os produtos vêm acompanhados de suas características, algumas delas irrelevantes, como cor, por exemplo.

Este resultado pode sim ter o seu valor, mas, o que queremos ver são as possíveis assossociações entre produtos.

Para isso, vamos retomar a análise do início, aplicando mais um tratamento, antes da transformação.

Vamos aproveitar os labels do top_50
```{r}
names(top_50)
```

Aplicando filtro aos dados

```{r}
dados_clean_2 = dados_clean
```

Agora, vamos aplicar à  descrição dos produtos uma função, visando padronizar sua definição, descartando caracteristicas que não nos interessam no momentos
```{r}
lista_produtos = c('NIGHT LIGHT', 'PLASTERS', 'SNACK BOXES',
                  'LUNCH BAG', 'LUNCH BOX', 'MINI CASES', 'PAPER CUPS',
                  'PAPER NAPKINS', 'PAPER PLATES', 'REGENCY CAKESTAND', 'ALARM CLOCK',
                  'CAKE CASES', 'JUMBO BAG', 'BIRTHDAY CARD', 'TEA SET', 'BAKING SET', 'PAPER BUNTING',
                  'RED POLKADOT PARTY CANDLES', 'SPINNING TOPS', 'CHILDRENS CUTLERY', 'PICNIC BAG', 'CHARLOTTE BAG',
                  'COFFEE MUG', 'TEA TOWELS', 'CHILDRENS UMBRELLA')


for(i in lista_produtos){

  indices = grep(i, dados_clean_2$Description)
  dados_clean_2$Description[indices] = i

}

head(dados_clean_2)

```

Filtrando produtos, para conter somente o da nossa lista
```{r}
dados_clean_2 = dados_clean_2[dados_clean_2$Description == lista_produtos, ]

dim(dados_clean_2)

dados_transacoes = dcast(dados_clean_2, InvoiceNo ~ Description, fun.aggregate = length)


```

Reorganizando colunas
```{r}
reordered = sort(colSums(dados_transacoes[, -1] == 0), decreasing = F)

dados_transacoes = dados_transacoes[, c('InvoiceNo', names(reordered))]

dados_matrix = as.matrix(dados_transacoes[ , -1])

transacoes = as(dados_matrix, 'transactions')

regras = apriori(transacoes,
                parameter = list(conf = 0.5, supp = 0.01, minlen = 3))

regras_clean = regras[!is.redundant(regras)]

```

Verificando quantidade das novas regras
```{r}
length(regras_clean)
```

Insppecionando as top-20
```{r}
inspect(head(sort(regras_clean, by = 'support', decreasing = T), 20))
```

Casting para data.frame
```{r}
regras_df <- as(regras_clean, "data.frame")
```

Iniciando visualização
```{r}

library(arulesViz)

```

```{r}

plot(regras_clean, measure = "support", shading = "confidence", method = "graph", engine = "html")

```

Em andamento!
